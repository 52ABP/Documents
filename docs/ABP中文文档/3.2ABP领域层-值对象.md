## 3.2 ABP领域层 - 值对象

### 3.2.1 简介

用来描述领域的特殊方面、且没有标识符的一个对象，叫做值对象。

实体有自己的唯一标识，而值对象是没有标识的。如果两个实体的标识是不同的，那么它们是两个不同的实体，即使这两个实体的其它属性值是相同的。想象一下两个不同的人但是他们有相同的姓和名以及年龄。但是，他们的标识是不同的话，那么他们就是不同的两个人。但是，对于地址(这是一个典型的值对象)类，如果这两个地址拥有相同的国家，城市，街道号等等。那么它们就是同一个地址。

在DDD中，值对象是领域对象的另一种类型，它可以包含业务逻辑并且是领域中不可或缺的一部分。

### 3.2.2 DDD中重要概念

#### 实体entity：

拥有唯一标识符一类对象，
但对象不是通过它们的属性定义的，而是通过一连串的连续性事件和标识定义的。

#### 值对象-value Object

+ 1.对某个对象是什么不感兴趣，只关心它拥有的属性

+ 2.用来描述领域的特殊方面、且没有标识符的一个对象，叫做值对象

+ 3.能被简单的创建和丢弃，生命周期中不会被持久化

+ 4.值对象可以被共享，值对象应该不可变

#### 服务-service（比webservice更细粒度服务描述）

+ 1.领域中的一些动词，代表了领域中的一个重要的行为，却不属于任何对象

    + 1)服务执行的操作涉及一个领域概念，这个领域概念通常不属于一个实体或者值对象

    + 2)被执行的操作涉及到领域中的其他的对象

    + 3)操作是无状态的
    
+ 2.服务对象不再拥有内置的状态

+ 3.服务对象担当重要的协调功能

+ 4.开发通用语言时，领域中的主要概念被引入到语言中，语言中的名词很容易被映射成对象。

语言中对应那些名词的动词变成那些对象的行为。但是有些领域中的动作，它们是一些动词，看上去却不属于任何对象。它们代表了领域中的一个重要的行为，所以不能忽略它们或者简单的把它们合并到某个实体或者值对象中。给一个对象增加这样的行为会破坏这个对象，让它看上去拥有了本该属于它的功能。

#### 模块

+ 1.将相关领域模型提炼分类，分而治之

+ 2.将高关联度的模型分组到一个模块以提供尽可能大的内聚（以能完整完成任务为准）

+ 3.分层是水平划分

+ 4.模块是垂直划分(Domain内部)

 
### 3.2.3 值对象基类 

ABP有一个基类 **ValueObject\<T\>**，为了能够更方便的创建值对象，我们可以继承该基类。如：**Address** 值对象：

```csharp
public class Address : ValueObject<Address>
{
    public Guid CityId { get; private set; } //对城市实体的引用

    public string Street { get; private set; }

    public int Number { get; private set; }

    public Address(Guid cityId, string street, int number)
    {
        CityId = cityId;
        Street = street;
        Number = number;
    }
}
```

值对象基类对==操作符进行了重写(还有其他相关的操作符和方法)来比较两个值对象是否相等，如果所有的属性的值都是相同的，那么断定这两个值对象相等。所以，如下测试是通过的：

```csharp
var address1 = new Address(new Guid("21C67A65-ED5A-4512-AA29-66308FAAB5AF"), "Baris Manco Street", 42);
var address2 = new Address(new Guid("21C67A65-ED5A-4512-AA29-66308FAAB5AF"), "Baris Manco Street", 42);

Assert.Equal(address1, address2);
Assert.Equal(address1.GetHashCode(), address2.GetHashCode());
Assert.True(address1 == address2);
Assert.False(address1 != address2);
```

即使它们在内存中是不同的对象，但是在领域中它们是相同的。

### 3.2.4 最佳实践

这里有一些对值对象设计建议：

+ 值对象应该被设计为不可变的(如上面的Address值对象)

+ 构成一个值对象的属性应该形成一个概念上的整体。例如：CityId，街道和号码不应该是构成Person实体的一部分，应该分离出来作为Address值对象。这样也使Person实体更简单。