# AddSingleton vs AddScoped vs AddTransient

> 本文作者：梁桐铭- 微软最有价值专家（Microsoft MVP） </br>
> 文章会随着版本进行更新，关注我获取最新版本 </br>
> 本文出自[《从零开始学 ASP.NET Core 与 EntityFramework Core》目录](https://www.52abp.com/Wiki/mvc/latest) </br>
> 视频课程效果更佳：[跨平台开发实战掌握 ASP.NET Core 与 EntityFramework Core
> ](https://www.52abp.com/College/Course/1) </br>

## AddSingleton vs AddScoped vs AddTransient 三者的差异行

在本视频中，我们将通过一个示例讨论 ASP.NET Core 中 AddSingleton()，AddScoped()和 AddTransient()方法之间的差异。

## IEmployeeRepository interface

考虑以下 IEmployeeRepository 接口。Add（）方法将新员工添加到存储库。GetAllEmployees（）

方法返回存储库中的所有 Employees。

公共接口 IEmployeeRepository
{
IEnumerable < Employee > GetAllEmployees（）;
员工添加（员工员工）;
}

员工类

公共级员工
{
public int Id { get ; 设置; }
public string Name { get ; 设置; }
}

MockEmployeeRepository

MockEmployeeRepository 实现 IEmployeeRepository。为了使示例简单，我们将内存中的雇员列表存储在私有字段\_employeeList 中。

公共类 MockEmployeeRepository ：IEmployeeRepository
{
private List <Employee> \_employeeList;

    public MockEmployeeRepository（）
    {
        _employeeList = new List <Employee>（）
    {
        新员工（）{Id = 1，姓名= “玛丽” }，
        new Employee（）{Id = 2，Name = “John” }，
        新员工（）{Id = 3，姓名= “Sam” }，
    };
    }

    公共员工添加（员工员工）
    {
        employee.Id = _employeeList.Max（e => e.Id）+ 1;
        _employeeList.Add（雇员）;
        回报员工;
    }

    public IEnumerable <Employee> GetAllEmployees（）
    {
        return _employeeList;
    }

}

HomeController

IEmployeeRepository 被注入 HomeController。响应 POST 请求的 Create（）操作方法使用注入的实例将 employee 对象添加到存储库。

公共类 HomeController ：控制器
{
private IEmployeeRepository \_employeeRepository;

    public HomeController（IEmployeeRepository employeeRepository）
    {
        _employeeRepository = employeeRepository;
    }

    [HTTPGET]
    public ViewResult Create（）
    {
        return View（）;
    }

    [HttpPost]
    public IActionResult Create（员工员工）
    {
        if （ModelState.IsValid）
        {
            员工newEmployee = _employeeRepository.Add（employee）;
        }

        return View（）;
    }

}

创建视图

我们使用@inject 指令将 IEmployeeRepository 服务注入到 Create 视图中。我们使用注入的服务来显示存储库中的员工总数。

@model 员工
@inject IEmployeeRepository empRepository

< form asp-controller =“home” asp-action =“create” method =“post”>
< div >
< label asp-for =“ Name ”> </ label >
< div >
< input asp-for =“ Name ”>
</ div >
</ div >

    < div >
        < button type =“submit”> 创建</ button >
    </ div >

    < div >
        员工总数= @ empRepository.GetAllEmployees（）。Count（）。ToString（）
    </ div >

</ form >

注册服务

ASP.NET 核心提供以下 3 种方法来使用依赖项注入容器注册服务。我们使用的方法决定了注册服务的生命周期。

AddSingleton（） - 顾名思义，AddSingleton（）方法创建一个 Singleton 服务。首次请求时会创建 Singleton 服务。然后，所有后续请求都使用相同的实例。因此，通常，每个应用程序只创建一次 Singleton 服务，并且在整个应用程序生命周期中使用该单个实例。

AddTransient（） - 此方法创建一个 Transient 服务。每次请求时，都会创建一个新的 Transient 服务实例。

AddScoped（） - 此方法创建一个 Scoped 服务。在范围内的每个请求中创建一个新的 Scoped 服务实例。例如，在 Web 应用程序中，它为每个 http 请求创建 1 个实例，但在同一 Web 请求中的其他调用中使用相同的实例。

在 ASP.NET Core 中，服务在 Startup.cs 文件的 ConfigureServices（）方法中注册。

public void ConfigureServices（IServiceCollection services）
{
services.AddMvc（）;
services.AddSingleton < IEmployeeRepository， MockEmployeeRepository >（）;
}
目前我们正在使用 AddSingleton（）方法来注册 MockEmployeeRepository 服务。
AddSingleton（）在第一次请求时创建服务的单个实例，并在需要该服务的所有位置重用该实例。
这意味着应用程序在整个生命周期内的所有请求都使用相同的实例。
目前，在我们的示例中，我们需要 2 个位置的 MockEmployeeRepository 服务实例 - 在 HomeController 和 Create 视图中创建操作方法。
此时，当我们导航到 http：// localhost：/ home / create 时，我们看到 Total Employees Count 为 3
要提供此请求，首先要创建 HomeController 的实例。HomeController 依赖于 IEmployeeRepository。
这是第一次请求服务实例。所以 asp.net 核心创建了一个服务实例并将其注入 HomeController。
创建视图还需要服务实例来计算员工总数。对于 singleton，使用相同的服务实例。因此，已创建的服务实例也会提供给“ 创建”视图。
现在，如果您在“名称”文本框中提供名称并单击“ 创建”按钮，则每次单击按钮时都会看到计数增加。
这是因为使用 Singleton 时，使用相同的对象，因此可以在所有 HTTP 请求的所有位置查看对对象所做的更改。
AddScoped

现在，使用 AddScoped（）方法注册服务。

public void ConfigureServices（IServiceCollection services）
{
services.AddMvc（）;
services.AddScoped < IEmployeeRepository， MockEmployeeRepository >（）;
}
向 http：// localhost：/ home / create 发出请求。
我们看到员工总数是 3。
提供名称，然后单击“ 创建”按钮。
将员工总数增加至 4。
当我们再次单击“ 创建”按钮时，“ 员工总数”仍为 4。
这是因为对于每个 http 请求的作用域服务，我们得到一个新实例。但是，如果在同一个 http 请求中，如果在视图和控制器等多个位置需要服务，则为该 http 请求的整个范围提供相同的实例。

如果我们将此与我们的示例相关联，则 HomeController 和 Create 视图将对给定的 http 请求使用相同的服务实例。这就是 Create 视图还能够看到 HomeController 的 Create action 方法添加的新员工的原因。因此，我们将员工总数计为 4。

但是每个新的 http 请求都将获得该服务的新实例。这就是在一个 http 请求中添加的员工无法在另一个 http 请求中看到的原因。所以这意味着每次我们点击 Create 按钮时，我们都会发出一个新的 http 请求，因此 Total Employees Count 不会超过 4。

AddTransient

最后让我们使用 AddTransient（）方法来注册我们的服务

public void ConfigureServices（IServiceCollection services）
{
services.AddMvc（）;
services.AddTransient < IEmployeeRepository， MockEmployeeRepository >（）;
}
向 http：// localhost：/ home / create 发出请求
我们看到员工总数是 3
提供名称，然后单击“ 创建”按钮。
请注意，在 Create 视图中，我们仍然看到 Total Employees Count 为 3
这是因为对于临时服务，每次请求服务实例时都会提供新实例，无论它是在同一 http 请求的范围内还是在不同的 http 请求中。

由于即使在给定 http 请求的同一范围内也提供了新实例，因此 Create 视图无法看到 HomeController 的 Create 操作添加的新员工。即使在添加新员工之后，这也是员工数量为 3 的原因。

范围服务与瞬态服务与单件服务

以下是范围服务和临时服务之间的主要区别。

使用作用域服务，我们在给定的 http 请求范围内获得相同的实例，但跨不同的 http 请求

获得新实例对于瞬态服务，每次请求实例时都会提供一个新实例，无论它是否在同一 http 的范围内请求或跨越不同的 http 请求

使用单例服务，只有一个实例。首次请求服务时，将创建一个实例，并且整个应用程序中的所有 http 请求都使用该实例。

## 文章说明

> 如果您觉得我的文章质量还不错，欢迎打赏，也可以订阅我的视频哦 </br>
> 未得到授权不得擅自转载本文内容,52abp.com 保留版权 </br>
> 感谢您对我的支持

## 关注微信公众号：角落的白板报

![公众号：角落的白板报](images/jiaoluowechat.png)
