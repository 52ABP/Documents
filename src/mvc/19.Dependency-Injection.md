# ASP.NET Core 依赖注入

在这个视频中，我们将通过一个例子详细讨论依赖注入。


## HomeController 
```
public class HomeController : Controller
{
    private IEmployeeRepository _employeeRepository;

    // Inject IEmployeeRepository using Constructor Injection
    public HomeController(IEmployeeRepository employeeRepository)
    {
        _employeeRepository = employeeRepository;
    }

    // Retrieve employee name and return
    public string Index()
    {
        return _employeeRepository.GetEmployee(1).Name;
    }
}
```

请注意 ： 
- HomeController依赖于IEmployeeRepository来检索Employee数据。
- 我们使用构造函数将IEmployeeRepository实例注入HomeController，而不是HomeController创建IEmployeeRepository实现的新实例。 
- 这称为构造函数注入，因为我们使用构造函数来注入依赖项。
- 请注意，我们将注入的依赖项分配给只读字段。这是一个很好的做法，因为它可以防止在方法中意外地为其分配另一个值。
- 此时，如果我们运行项目，则会收到以下错误
InvalidOperationException：尝试激活“EmployeeManagement.Controllers.HomeController”时无法解析类型“EmployeeManagement.Models.IEmployeeRepository”的服务。
- 这是因为如果有人请求实现IEmployeeRepository的对象，ASP .NET依赖注入容器不知道要提供哪个对象实例
- IEmployeeRepository可能有多个实现。在我们的项目中，我们只有一个实现，那就是MockEmployeeRepository
- 顾名思义，MockEmployeeRepository使用内存中的员工模拟数据。
- 在我们即将发布的视频中，我们将讨论为IEmployeeRepository提供另一个实现，该实现从SQL Server数据库中检索员工数据。
- 现在，让我们使用MockEmployeeRepository。
- 要修复InvalidOperationException错误，我们需要在ASP.NET核心中使用依赖注入容器注册MockEmployeeRepository类。
- 我们在Startup类的ConfigureServices（）方法中执行此操作


## 使用ASP.NET核心依赖注入容器注册服务：  


ASP.NET核心提供以下3种方法来使用依赖项注入容器注册服务。我们使用的方法决定了注册服务的生命周期。

AddSingleton（） - 顾名思义，AddSingleton（）方法创建一个Singleton服务。首次请求时会创建Singleton服务。然后，所有后续请求都使用相同的实例。因此，通常，每个应用程序只创建一次Singleton服务，并且在整个应用程序生命周期中使用该单个实例。

AddTransient（） - 此方法创建一个Transient服务。每次请求时，都会创建一个新的Transient服务实例。 

AddScoped（） - 此方法创建一个Scoped服务。在范围内的每个请求中创建一个新的Scoped服务实例。例如，在Web应用程序中，它为每个http请求创建1个实例，但在同一Web请求中的其他调用中使用相同的实例。

请不要担心，如果这一点有点令人困惑。我们将在本系列即将发布的视频中多次重新审视这三种方法。


现在，要修复InvalidOperationException错误，让我们使用AddSingleton（）向ASP.NET Core Dependency Injection容器注册MockEmployeeRepository类方法如下图所示。因此，与此代码原地的，如果有人问IEmployeeRepository，实例MockEmployeeRepository将提供。 

```
public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc();
    services.AddSingleton<IEmployeeRepository, MockEmployeeRepository>();
}
```
在这一点上，您可能在想，为什么我们必须做这一切。为什么我们不能使用new关键字在HomeController中简单地创建MockEmployeeRepository类的实例，如下所示。 
```
public class HomeController : Controller
{
    private readonly IEmployeeRepository _employeeRepository;

    // Inject IEmployeeRepository using Constructor Injection
    public HomeController(IEmployeeRepository employeeRepository)
    {
        _employeeRepository = new MockEmployeeRepository();
    }

    // Retrieve employee name and return
    public string Index()
    {
        return _employeeRepository.GetEmployee(1).Name;
    }
}

```

好吧，这使HomeController与MockEmployeeRepository紧密耦合。稍后如果我们为IEmployeeRepository提供新的实现，并且如果我们想要使用新的实现而不是MockEmployeeRepository，我们必须更改HomeController中的代码。您可能会想，这只是一行代码更改，所以这并不难。

那么，如果我们在我们的应用程序中的50个其他控制器中使用了这个MockEmployeeRepository 呢？
所有50个控制器中的代码都必须更改。这不仅乏味而且容易出错。

因此，在短，使用的用于创建依赖关系实例的new关键字会产生紧密耦合，因此您的应用程序很难更改。通过依赖注入，我们不会有这种紧密耦合。 

使用依赖注入，即使我们在我们的应用程序中的50个其他控制器中使用了MockEmployeeRepository，如果我们想用不同的实现交换它，我们只需要在Startup.cs文件中更改以下一行代码。请注意，我们现在使用DatabaseEmployeeRepository而不是MockEmployeeRepository。  


```
public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc();
    services.AddSingleton<IEmployeeRepository, DatabaseEmployeeRepository>();
}

```

单元测试也变得更加容易，因为我们可以通过依赖注入轻松地交换依赖项。如果这有点令人困惑，请不要担心。我们将在即将发布的视频中为IEmployeeRepository提供不同的实现。此新实现将从SQL Server数据库中检索数据。然后，我们将使用DatabaseEmployeeRepository实现替换MockEmployeeRepository实现。此时，您将了解依赖注入提供的功能和灵活性。





















